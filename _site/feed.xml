<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AntoniaHE Blog</title>
    <description>Every failure is leading towards success.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 13 Jun 2018 01:56:23 +0800</pubDate>
    <lastBuildDate>Wed, 13 Jun 2018 01:56:23 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>about Array</title>
        <description>&lt;h3 id=&quot;创建一个数组&quot;&gt;创建一个数组&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = new Array() // []
let a = [1,2,3]
let a = Array(3) // [,,] 长度为3的数组
let a = Array(3,4,5) // [3,4,5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;arrayof-es6&quot;&gt;Array.of() ES6&lt;/h5&gt;
&lt;p&gt;这个方法返回参数值组成的数组,没有参数，就返回一个空数组&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = Array.of(3,4,'sss',22) // [3, 4, &quot;sss&quot;, 22]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。 在上面的创建栗子中，&lt;code class=&quot;highlighter-rouge&quot;&gt;Array(3)&lt;/code&gt; 是一个长度为3的空数组，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Array(3,4,5)&lt;/code&gt; 返回的是&lt;code class=&quot;highlighter-rouge&quot;&gt;[3,4,5]&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;arraryfrom-es6&quot;&gt;Arrary.from() ES6&lt;/h5&gt;
&lt;p&gt;用于将两类对象转化为真正的数组，不改变原对象，返回新的数组。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Array.from('hello') // ['h','e','l','l','o']
let a1 = [...new Set(Array.from('hello'))] // ['h','e','l','o']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;方法&quot;&gt;方法&lt;/h3&gt;
&lt;h4 id=&quot;改变原数组的9个方法&quot;&gt;改变原数组的9个方法&lt;/h4&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;ES5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;  &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unshift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;ES6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;copyWithin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fill&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;splice-添加删除数组元素&quot;&gt;splice() 添加/删除数组元素&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 添加
array.splice(index,howmany,item1,.....,itemX)
// index: 必需,规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
// howmany: 要删除的个数，0表示不删除，返回原数组
// item1, ..., itemX： 可选。向数组添加的新项目。
let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0, 3); // [1,2,3]
console.log(a); // [4,5,6,7]
// 从数组下标0开始，删除3个元素
let item = a.splice(-1, 3); // [7]
// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7

// 删除
let item = b.splice(-1,0,'添加1','添加2'); // item []没有删除元素，返回空数组
console.log(b); // [1,2,3,4,5,6,'添加1','添加2',7]在最后一个元素的前面添加两个元素
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;数组如果元素不够，会删除到最后一个元素为止&lt;/li&gt;
  &lt;li&gt;操作的元素，包括开始的那个元素&lt;/li&gt;
  &lt;li&gt;可以添加很多个元素&lt;/li&gt;
  &lt;li&gt;添加是在开始的元素前面添加的&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;sort-排序&quot;&gt;sort() 排序&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;数字类型的数组排序&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 返回升序数组
let array =  [10, 1, 3, 4,20,4,25,8]
array.sort(function(a,b){
    return a - b
})
// [1, 3, 4, 4, 8, 10, 20, 25]

// 降序
array.sort(function(a,b){
    return b - a
})
// [25, 20, 10, 8, 4, 4, 3, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;数组多条件排序
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// array是一个对象数组，按一下方式进行排序
array.sort(function(a,b){
  if(a.id === b.id){// 如果id的值相等，按照age的值降序
       return b.age - a.age
  }else{ // 如果id的值不相等，按照id的值升序
      return a.id - b.id
  }
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h5 id=&quot;pop-删除一个数组中的最后的一个元素&quot;&gt;pop() 删除一个数组中的最后的一个元素&lt;/h5&gt;
    &lt;p&gt;pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr = [1,2,4,5,6,8]
let item = arr.pop() // item 8
arr // [1,2,4,5,6]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h5 id=&quot;shift-删除数组的第一个元素&quot;&gt;shift() 删除数组的第一个元素&lt;/h5&gt;
    &lt;p&gt;shift()方法删除数组的第一个元素，并返回这个元素。&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr = [1,2,4,5,6,8]
let item = arr.shift() // item 1
arr // [2,4,5,6,8]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h5 id=&quot;push-向数组的末尾添加元素并返回新的长度&quot;&gt;push() 向数组的末尾添加元素，并返回新的长度&lt;/h5&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let list = [2,4,5]
list.push('2222')
// list [2,4,5,'2222']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h5 id=&quot;unshift-在数组的开头添加一个或多个元素并返回新的长度&quot;&gt;unshift() 在数组的开头添加一个或多个元素，并返回新的长度&lt;/h5&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let list = [2,3,4,5]
let len = list.unshift('2222') // 5
// list ['2222',2,3,4,5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h5 id=&quot;reverse-颠倒数组中元素的顺序&quot;&gt;reverse() 颠倒数组中元素的顺序.&lt;/h5&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var listA = [2,4,6,9,2,3,7]
listA.sort((a,b) =&amp;gt;{
  return a - b
})
// listA [2, 2, 3, 4, 6, 7, 9]
listA.reverse() // [9, 7, 6, 4, 3, 2, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h5 id=&quot;copywithin-指定位置的成员复制到其他位置-es6&quot;&gt;copyWithin() 指定位置的成员复制到其他位置 ES6&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array.copyWithin(target, start = 0, end = this.length)
// target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
// start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
// end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。

var listA = [2,4,6,9,2,3,7]
listA.copyWithin(1, -3, -2) // [2,2,6,9,2,3,7]
// 注意：读了几个元素就从开始被替换的地方替换几个元素
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;fill-填充数组-es6&quot;&gt;fill() 填充数组 ES6&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var l = [2,4,5,8,9,10]
l.fill(7,3,5) 
// 要填充的数值是7，从第三个位置开始，到第五个位置前结束
// [2,3,5,7,7,10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;不改变原数组的方法8个&quot;&gt;不改变原数组的方法(8个)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ES5：
slice、join、toLocateString、toStrigin、cancat、indexOf、lastIndexOf
// ES7：
includes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;slice-浅拷贝数组的元素&quot;&gt;slice() 浅拷贝数组的元素&lt;/h5&gt;
&lt;p&gt;方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。&lt;/p&gt;

&lt;p&gt;新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var l = [2,4,5,6,8,2,4]
var l2 = l.slice(0, 4) // [2,4,5,6]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = [{name:'hemei'}]
let b = a.slice()
console.log(b,a)
a[0].name = 'hello'
b // [{name: 'hello'}]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;join-数组转字符串&quot;&gt;join() 数组转字符串&lt;/h5&gt;
&lt;p&gt;默认使用逗号作为分隔符&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = ['hello','world'];
let str = a.join(); // 'hello,world'
let str2 = a.join('+'); // 'hello+world'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;join()/toString()&lt;/code&gt;方法在数组元素是数组的时候，会将里面的数组也调用&lt;code class=&quot;highlighter-rouge&quot;&gt;join()/toString()&lt;/code&gt;,如果是对象的话，对象会被转为&lt;code class=&quot;highlighter-rouge&quot;&gt;[object Object]&lt;/code&gt;字符串。&lt;/p&gt;

&lt;h5 id=&quot;tolocalestring-数组转字符串&quot;&gt;toLocaleString() 数组转字符串&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a=[{name:'OBKoro1'},23,'abcd',new Date()];
let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用数组的&lt;code class=&quot;highlighter-rouge&quot;&gt;toLocaleString&lt;/code&gt;方法，数组中的每个元素都会调用自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;toLocaleString&lt;/code&gt;方法，对象调用对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;toLocaleString&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Date&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;toLocaleString&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;tostring-数组转字符串-不推荐使用&quot;&gt;toString() 数组转字符串 不推荐使用&lt;/h5&gt;
&lt;p&gt;跟join方法一样，join可以定义分隔符，toString没有。&lt;/p&gt;

&lt;p&gt;当数组和字符串操作的时候，js 会自己调用这个方法将数组自动转换成字符串。&lt;/p&gt;

&lt;h5 id=&quot;cancat--用于将两个或多个数组进行合并操作返回一个新数组&quot;&gt;cancat  用于将两个或多个数组进行合并操作，返回一个新数组。&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var newArr = oldArray.concat(arrayX,arrayX,......,arrayX)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var old1 = [{name: '222',age: 12}]
var old2 = [{name2: '2xxxx22',age2: 122}]
var new1 = old1.concat(old2) // [{name: '222',age: 12}, {name2: '2xxxx22',age2: 122}]
old1[0].name = 'hemei'
new1 // [{name: 'hemei',age: 12}, {name2: '2xxxx22',age2: 122}]
// 复杂类型进行合并，属于浅拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;es6扩展运算符合并数组&quot;&gt;ES6扩展运算符…合并数组&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = [2, 3, 4, 5]
let b = [ 4,...a, 4, 4]
console.log(b); //  [4,2,3,4,5,4,4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;indexof-查找数组是否存在某个元素返回下标&quot;&gt;indexOf() 查找数组是否存在某个元素，返回下标.&lt;/h5&gt;
&lt;p&gt;返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array.indexOf(searchElement,fromIndex)
// 被查找的元素, 开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。

// indexOf()不能识别NaN
// 数组的indexOf使用严格相等===搜索元素
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = ['hemei','dddd','ssss']
arr.indexOf('h') // -1
arr.indexOf('hemei') // 0
arr.indexOf('dddd') // 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用场景&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数组去重&lt;/li&gt;
  &lt;li&gt;根据获取的数组下标执行操作，改变数组中的值等。&lt;/li&gt;
  &lt;li&gt;判断是否存在，执行操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;lastindexof-查找指定元素在数组中的最后一个位置&quot;&gt;lastIndexOf() 查找指定元素在数组中的最后一个位置&lt;/h5&gt;
&lt;p&gt;方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arr.lastIndexOf(searchElement,fromIndex)
// 被查找的元素. 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。
// fromIndex: 
// 正值。如果该值大于或等于数组的长度，则整个数组会被查找
// 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)
// 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;includes-查找数组是否包含某个元素-返回布尔-es7&quot;&gt;includes() 查找数组是否包含某个元素 返回布尔 ES7&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array.includes(searchElement,fromIndex=0)
// searchElement: 被查找的元素,
// fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;includes方法是为了弥补indexOf方法的缺陷而出现的:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;indexOf方法不能识别NaN&lt;/li&gt;
  &lt;li&gt;indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;遍历方法12个&quot;&gt;遍历方法(12个)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ES5：
forEach、every 、some、 filter、map、reduce、reduceRight、
ES6：
find、findIndex、keys、values、entries
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;foreach&quot;&gt;forEach&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array.forEach(function(currentValue, index, arr), thisValue)
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身
4. thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于forEach，无法中途退出循环，只能用return退出本次回调，进行下一次回调。它总是返回 undefined值,即使你return了一个值。&lt;/p&gt;

&lt;h5 id=&quot;every-检测数组所有元素是否都符合判断条件&quot;&gt;every 检测数组所有元素是否都符合判断条件&lt;/h5&gt;
&lt;p&gt;语法同上&lt;/p&gt;

&lt;p&gt;返回值规则：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。&lt;/li&gt;
  &lt;li&gt;如果所有元素都满足条件，则返回 true。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arrays = [2,3,4,5,6,7,8,9]
arrays.every(item =&amp;gt; item &amp;gt; 1) // true
arrays.every(item =&amp;gt; item &amp;gt; 2) // false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;some-数组中是否有满足判断条件的元素&quot;&gt;some 数组中是否有满足判断条件的元素&lt;/h5&gt;
&lt;p&gt;语法同上&lt;/p&gt;

&lt;p&gt;返回值规则:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测.&lt;/li&gt;
  &lt;li&gt;如果没有满足条件的元素，则返回false。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arrays.some(item =&amp;gt; item &amp;gt; 2) // true
arrays.some(item =&amp;gt; item &amp;gt; 10) // false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;filter-过滤原始数组返回新数组&quot;&gt;filter 过滤原始数组，返回新数组&lt;/h5&gt;
&lt;p&gt;返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let new_array = arr.filter(function(currentValue, index, arr), thisArg)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arrays.filter(item =&amp;gt; item &amp;gt; 3) // [4, 5, 6, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;map-对数组中的每个元素进行处理返回新的数组&quot;&gt;map 对数组中的每个元素进行处理，返回新的数组&lt;/h5&gt;
&lt;p&gt;语法同上&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arrays.map(item =&amp;gt; {
    if(item &amp;gt; 3) {
        item = 10
    }else {
        item = item
    }
    return item
}) // [2, 3, 10, 10, 10, 10, 10, 10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;reduce-为数组提供累加器合并为一个值&quot;&gt;reduce 为数组提供累加器，合并为一个值&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
// 参数
1. total(必须)，初始值, 或者上一次调用回调返回的值
2. currentValue(必须),数组当前元素的值
3. index(可选), 当前元素的索引值
4. arr(可选),数组对象本身
5 nitialValue(可选): 指定第一次回调 的第一个参数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let sum = [0, 1, 2, 3].reduce(function (a, b) {
  return a + b
}, 0) // 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;reduceright-从右至左累加&quot;&gt;reduceRight 从右至左累加&lt;/h5&gt;
&lt;p&gt;这个方法除了与reduce执行方向相反外，其他完全与其一致.&lt;/p&gt;
&lt;h5 id=&quot;find--findindex-根据条件找到数组成员-es6&quot;&gt;find() &amp;amp; findIndex() 根据条件找到数组成员 ES6&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个方法都可以识别NaN,弥补了indexOf的不足.&lt;/p&gt;

&lt;h5 id=&quot;keysvaluesentries-遍历键名遍历键值遍历键名键值&quot;&gt;keys()&amp;amp;values()&amp;amp;entries() 遍历键名、遍历键值、遍历键名+键值&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;参考&quot;&gt;参考：&lt;/h5&gt;

&lt;p&gt;https://juejin.im/post/5b0903b26fb9a07a9d70c7e0?utm_source=gold_browser_extension#heading-7&lt;/p&gt;

&lt;h5 id=&quot;总结&quot;&gt;总结:&lt;/h5&gt;
&lt;p&gt;很多方法其实在日常的开发中是用过的，只是没有这么系统的来统计出来。&lt;/p&gt;

&lt;p&gt;感谢 &lt;code class=&quot;highlighter-rouge&quot;&gt;OBKoro1&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/06/13/index/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/13/index/</guid>
        
        
      </item>
    
      <item>
        <title>js--原型和原型链</title>
        <description>&lt;h5 id=&quot;什么是原型&quot;&gt;什么是原型&lt;/h5&gt;
&lt;h6 id=&quot;prototype&quot;&gt;prototype&lt;/h6&gt;
&lt;p&gt;每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。
函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型.&lt;/p&gt;
&lt;h6 id=&quot;__proto__&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__proto__&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--使用构造函数创建一个对象--&amp;gt;
function People() {}
const people = new People()
console.log(people.__proto__ === People.prototype) 
// true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;实例的__proto__属性指向构造函数的原型&lt;/p&gt;
&lt;h6 id=&quot;constructor&quot;&gt;constructor&lt;/h6&gt;
&lt;p&gt;原型的constructor属性指向构造函数、&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;People === People.prototype.constructor 
// true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;实例与原型&quot;&gt;实例与原型&lt;/h5&gt;
&lt;p&gt;当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;People.prototype.name = 'hemei'
people.name = 'ahhhh'
console.log(people.name)

delete people.name
console.log(people.name)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;原型的原型&quot;&gt;原型的原型&lt;/h5&gt;
&lt;p&gt;原型对象就是通过 Object 构造函数生成的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Peopel.prototype.__proto__ -&amp;gt; Object.prototype
Object.prototype.constractor -&amp;gt; Object()
Object.protptype.__proto__ === null // true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;instanceof-表示的就是一种继承关系或者原型链的结构&quot;&gt;instanceof 表示的就是一种继承关系，或者原型链的结构。&lt;/h6&gt;
&lt;h6 id=&quot;关系图&quot;&gt;关系图：&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;../../../../img/article-images/proto.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原型链关系图。
&lt;img src=&quot;../../../../img/article-images/prototype.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;文章参考&quot;&gt;文章参考：&lt;/h6&gt;
&lt;p&gt;https://github.com/mqyqingfeng/Blog/issues/2&lt;/p&gt;

&lt;p&gt;https://www.cnblogs.com/wangfupeng1988/p/3977924.html&lt;/p&gt;
</description>
        <pubDate>Mon, 28 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/28/index/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/28/index/</guid>
        
        
      </item>
    
      <item>
        <title>webpack 4.0 进阶</title>
        <description>&lt;h5 id=&quot;安装一波&quot;&gt;安装一波&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; npm install -g webpack // 全局安装webpack
 npm init // 初始化项目
 npm install --save-dev webpack //–save是要保存到package.json中，dev是在开发时使用这个包，而生产环境中不使用。
 注意：当使用webpack -v 出现需要安装webpack-cli 的情况时，需要全局安装 webpack-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;来操作一波&quot;&gt;来，操作一波&lt;/h5&gt;
&lt;p&gt;在项目文件夹的根目录建立两个文件夹，分别是src文件夹和dist文件夹：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;src文件夹：用来存放我们编写的javascript代码，可以简单的理解为用JavaScript编写的模块。&lt;/li&gt;
  &lt;li&gt;dist文件夹：用来存放供浏览器读取的文件，这个是webpack打包成的文件。&lt;/li&gt;
  &lt;li&gt;简单理解就是：src是源码文件，dist是我们编译打包好的文件；一个用于开发环境，一个用于生产环境。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;纪念第一次webpack打包&quot;&gt;纪念第一次Webpack打包&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; webpack {entry file} {destination for bundled file}
// {entery file}:入口文件的路径，本文中就是src/entery.js的路径；
// {destination for bundled file}:填写打包后存放的路径。
例如：
    webpack src/entry.js dist/bundle.js
    将src里面entry.js 文件打包到dist里面的bundle.js里面
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;配置文件入口和出口&quot;&gt;配置文件：入口和出口&lt;/h5&gt;
&lt;h6 id=&quot;配置文件webpackconfigjs&quot;&gt;配置文件webpack.config.js&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports={
    //入口文件的配置项
    entry:{},
    //出口文件的配置项
    output:{},
    //模块：例如解读CSS,图片如何转换，压缩
    module:{},
    //插件，用于生产模版和各项功能
    plugins:[],
    //配置webpack开发服务功能
    devServer:{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;配置文件-服务和热更新&quot;&gt;配置文件： 服务和热更新&lt;/h5&gt;
&lt;h6 id=&quot;设置webpack-dev-server&quot;&gt;设置webpack-dev-server&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;安装：npm install webpack-dev-server –save-dev
在webpack.config.js里面配置：
devServer: {
    //设置基本目录结构，用于找到程序打包地址。
    contentBase:path.resolve(__dirname,'dist'),
    //服务器的IP地址，可以使用IP也可以使用localhost
    host:'localhost',
    //服务端压缩是否开启
    compress:true,
    //配置服务端口号
    port: 1818
}
在package.json 配置：
&quot;script&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;模块打包css&quot;&gt;模块打包：css&lt;/h5&gt;
&lt;h6 id=&quot;关于loaders&quot;&gt;关于Loaders。&lt;/h6&gt;
&lt;p&gt;它是webpack的重要功能，可以对不同的文件格式进行特定处理。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;例如：
可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。
可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。
可以把React中的JSX转换成JavaScript代码。

注意：所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置。
在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;loaders配置属性&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；
use：loader名称，就是你要使用模块的名称；
include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；
query：为loaders提供额外的设置选项（可选）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;打包css文件&quot;&gt;打包CSS文件&lt;/h6&gt;
&lt;p&gt;新建css文件并引入到index.js中。
使用loader来解析css文件，涉及到2个loader：&lt;code class=&quot;highlighter-rouge&quot;&gt;style-loader，css-loader&lt;/code&gt;；
安装对应的模块：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install style-loader --save-dev
npm install css-loader --save-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在webpack.config.js里面配置&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;modules: {
    rules: [
        {
           test: /\.css$/,
           // 这里的use，也可以使用loader，都是表示使用的模块
           use: ['style-loader', 'css-loader']
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;插件配置配置js压缩&quot;&gt;插件配置：配置JS压缩&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 在webpack.config.js中引入uglifyjs-webpack-glugin插件
const uglify = require('uglifyjs-webpack-plugin')
// plugins配置里new一个 uglify对象
plugins:[
    new uglify()
],
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;插件配置html文件的发布如何把html文件打包到我们的生产路径下&quot;&gt;插件配置：HTML文件的发布–如何把html文件打包到我们的生产路径下。&lt;/h5&gt;
&lt;h6 id=&quot;打包html文件&quot;&gt;打包HTML文件&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 配置webpack.config.js文件，先引入我们的html-webpack-plugin插件。
const htmlPlugin = require('html-webpack-plugin')
// 安装模块
npm install --save-dev html-webpack-plugin
// 进行插件配置，放在plugin里面
new htmlPlugin({
    minify:{
        removeAttributeQuotes:true
    },
    hash:true,
    template:'./src/index.html'
})
minify：是对html文件进行压缩，removeAttrubuteQuotes是去掉属性的双引号。
hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。
template：是要打包的html模版路径和文件名称。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;图片css中的图片处理&quot;&gt;图片：CSS中的图片处理&lt;/h5&gt;
&lt;p&gt;我们直接使用图片，webpack打包是会报错的，因为我们没有做图片相关的打包配置，缺少loader的解析。这里涉及到2个用于图片解析的loader，url-loader,file-loader&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 安装
npm install --save-dev file-loader url-loader
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;file-loader&lt;/code&gt;：解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;url-loader&lt;/code&gt;：如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 配置
rules: [{
    test: '/\.(png|gif|jpg)/',
    use: [{
            loader: 'url-loader',
            options: {
                limit: 500000
            }
        }
    ]
}]
// test:/\.(png|jpg|gif)/是匹配图片文件后缀名称。
// use：是指定使用的loader和loader的配置参数。
// limit：是把小于500000B的文件打成Base64的格式，写入JS。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上我们只是用了url-loader,是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;url-loader&lt;/code&gt;封装了&lt;code class=&quot;highlighter-rouge&quot;&gt;file-loader&lt;/code&gt;。
url-loader工作分两种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;文件大小小于limit参数，url-loader将会把文件转为DataURL（Base64格式）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;css--图片css分离与图片路径处理&quot;&gt;css &amp;amp; 图片：CSS分离与图片路径处理&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --save-dev extract-text-webpack-plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;图片处理html中的图片&quot;&gt;图片：处理HTML中的图片&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install html-withimg-loader --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;css进阶less文件的打包和分离&quot;&gt;CSS进阶：Less文件的打包和分离&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;安装：
npm install --save-dev less less-loader
{
  test: /\.less$/,
  use: ['style-loader', 'css-loader', 'less-loader']
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;css进阶sass文件的打包和分离&quot;&gt;CSS进阶：SASS文件的打包和分离&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;安装：
npm install --save-dev node-sass sass-loader
{
  test: /\.scss$/,
  use: ['style-loader','css-loader', 'sass-loader']
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;css进阶自动处理css3属性前缀&quot;&gt;CSS进阶：自动处理CSS3属性前缀&lt;/h5&gt;
&lt;h6 id=&quot;安装-postcss-loader-和autoprefixer&quot;&gt;安装 postcss-loader 和autoprefixer&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 新建 postcss.config.js 文件,设置
module.exports = {
    plugins: [
        require('autoprefixer')
    ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;loader-配置&quot;&gt;loader 配置&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    test: /\.css$/,
    use: [
        {
          loader: &quot;style-loader&quot;
        }, {
          loader: &quot;css-loader&quot;
        }, {
          loader: &quot;postcss-loader&quot;
        }
    ]
}
// 提取css
{
    test: /\.css$/,
    use: extractTextPlugin.extract({
        fallback: 'style-loader',
        use: [
            { loader: 'css-loader', options: { importLoaders: 1 } },
            'postcss-loader'
        ]
    })
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;css进阶消除未使用的css&quot;&gt;CSS进阶：消除未使用的CSS&lt;/h5&gt;
&lt;h6 id=&quot;purifycss&quot;&gt;PurifyCSS&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 安装  -D代表的是–save-dev
npm i -D purifycss-webpack purify-css
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;glob&quot;&gt;glob&lt;/h6&gt;
&lt;p&gt;需要同步检查html模板，所以我们需要引入node的glob对象使用。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constc  glob = require('glob')
const PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;)
&amp;lt;!--设置plugin， 插件必须配合extract-text-webpack-plugin这个插件--&amp;gt;
plugins:[
    new PurifyCSSPlugin({
        paths: glob.sync(path.join(__dirname, 'src/*.html')),
    })
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;给webpack增加babel支持&quot;&gt;给webpack增加babel支持&lt;/h5&gt;
&lt;h6 id=&quot;babel&quot;&gt;babel&lt;/h6&gt;
&lt;h6 id=&quot;babel其实是一个编译javascript的平台它可以做的事&quot;&gt;Babel其实是一个编译JavaScript的平台，它可以做的事：&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;使用下一代的javaScript代码(ES6,ES7….)，即使这些标准目前并未被当前的浏览器完全支持。&lt;/li&gt;
  &lt;li&gt;使用基于JavaScript进行了扩展的语言，比如React的JSX。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--安装--&amp;gt;
&amp;lt;!--解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包--&amp;gt;
npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react

{
    test:/\.(jsx|js)$/,
    use:{
        loader:'babel-loader',
        options:{
            presets:[
                &quot;es2015&quot;,&quot;react&quot;
            ]
        }
    },
    exclude:/node_modules/
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;babelrc配置&quot;&gt;.babelrc配置&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;presets&quot;:[&quot;react&quot;,&quot;es2015&quot;]
}
&amp;lt;!--webpack.config.js配置--&amp;gt;
{
    test:/\.(jsx|js)$/,
    use:{
        loader:'babel-loader',
    },
    exclude:/node_modules/
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;env&quot;&gt;ENV&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--官方推荐使用的是babel-preset-env--&amp;gt;
npm install --save-dev babel-preset-env

{
    &quot;presets&quot;:[&quot;react&quot;,&quot;env&quot;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;打包第三方库&quot;&gt;打包第三方库&lt;/h5&gt;
&lt;p&gt;jquery为栗子
第一种方式：只使用到webpack打包&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --save jquery
&amp;lt;!--引入--&amp;gt;
import $ from 'jquery'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第二种方式：全局引入&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--在webpac.config.js文件引入webpack，plugin里面配置jQuery--&amp;gt;
const webpack = require('webpack')
&amp;lt;!-- plugin--&amp;gt;
plugin:[
    new webpack.ProvidePlugin({
        $: 'jquery'
    })

]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;实战技巧watch的正确使用方法&quot;&gt;实战技巧：watch的正确使用方法&lt;/h5&gt;
&lt;p&gt;使用 webpack –watch&lt;/p&gt;
&lt;h6 id=&quot;bannerplugin插件js中加上我们的版权或开发者声明&quot;&gt;BannerPlugin插件:JS中加上我们的版权或开发者声明&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new webpack.BannerPlugin('hemei 版权所有')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;优化黑技能&quot;&gt;优化黑技能&lt;/h5&gt;
&lt;p&gt;在jquery的引入中，我们使用了2中方式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;import引入方法：引用后不管你在代码中使用不适用该类库，都会把该类库打包起来，这样有时就会让代码产生冗余。&lt;/li&gt;
  &lt;li&gt;ProvidePlugin引入方法：引用后只有在类库使用时，才按需进行打包，所以建议在工作使用插件的方式进行引入。&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;抽离jquery&quot;&gt;抽离JQuery&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--修改入口文件--&amp;gt;
 entry:{
    entry:'./src/entry.js',
    jquery:'jquery'
 }
 &amp;lt;!--设置以下属性--&amp;gt;
 optimization: {
    splitChunks: {
      &amp;lt;!--name对应入口文件中的名字，我们起的是jQuery--&amp;gt;
      name:'jquery',
      &amp;lt;!--最小打包的文件模块数，这里直接写2就好--&amp;gt;
      minChunks: 2
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行npm run dev  jquery和entry已经分离。&lt;/p&gt;

&lt;h5 id=&quot;实战技巧静态资源集中输出&quot;&gt;实战技巧：静态资源集中输出&lt;/h5&gt;

&lt;h6 id=&quot;使用copy-webpack-plugin&quot;&gt;使用copy-webpack-plugin&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --save-dev copy-webpack-plugin
&amp;lt;!--webpack.config.js--&amp;gt;
const copyWebpackPlugin= require('copy-webpack-plugin')
&amp;lt;!--plugin--&amp;gt;
new copyWebpackPlugin([{
    from:__dirname+'/src/public',
    to:'./public'
}])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;from:要打包的静态资源目录地址，这里的__dirname是指项目目录下，是node的一种语法，可以直接定位到本机的项目目录中。&lt;/li&gt;
  &lt;li&gt;to:要打包到的文件夹路径，跟随output配置中的目录。所以不需要再自己加__dirname。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;实战技巧json配置文件使用&quot;&gt;实战技巧：Json配置文件使用&lt;/h5&gt;
&lt;p&gt;普通文件引入&lt;/p&gt;
&lt;h5 id=&quot;热更新&quot;&gt;热更新&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new webpack.HotModuleReplacementPlugin()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;边看这篇文章边操作，现在自己会搭一个框架了。中间遇到了很多问题，也参考了网上的大神的经验文档。&lt;/p&gt;
&lt;h5 id=&quot;遇见的坑&quot;&gt;遇见的坑：&lt;/h5&gt;
&lt;p&gt;常见的： https://blog.csdn.net/sinat_17775997/article/details/61924901&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;webpack打包，css样式名变成了带hash的值。
因为设置了modules：true 。取消就不会有了。&lt;/li&gt;
  &lt;li&gt;当出现 The following asset(s) exceed the recommended size limit (244 KiB)文件大小限制的warning时，一般开发环境的文件都比较大。
在webpack里面配置
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;performanc: {
  hints:  dev ? false : 'warning'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h5 id=&quot;感谢大神技术胖&quot;&gt;感谢大神技术胖&lt;/h5&gt;
    &lt;h5 id=&quot;原文httpjspangcom20170916webpack3-2&quot;&gt;原文：http://jspang.com/2017/09/16/webpack3-2/&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 27 May 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/05/27/index/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/05/27/index/</guid>
        
        
      </item>
    
      <item>
        <title>关于ES6</title>
        <description>&lt;h3 id=&quot;1-let-和-const-命令&quot;&gt;1. let 和 const 命令&lt;/h3&gt;
&lt;p&gt;ES6 新增了&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;命令，用来声明变量。只在&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;所在的区块内有效。&lt;/p&gt;
&lt;h4 id=&quot;let&quot;&gt;let&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;不存在变量提升。&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;会有变量提升的情况，也就是可以在声明之前使用，其值为&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;定义的变量，只能在声明后使用，否则报错&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;暂时性死区。在代码块内，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（&lt;code class=&quot;highlighter-rouge&quot;&gt;temporal dead zone&lt;/code&gt;，简称 &lt;code class=&quot;highlighter-rouge&quot;&gt;TDZ&lt;/code&gt;）。&lt;/li&gt;
  &lt;li&gt;不允许重复声明。&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;不允许在相同作用域内，重复声明同一个变量。&lt;/li&gt;
  &lt;li&gt;块级作用域。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;为什么需要块级作用域?
第一种场景，如果使用var内层变量可能会覆盖外层变量。
第二种场景，用来计数的循环变量泄露为全局变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;ES6的块级作用域：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1() {
let n = 5;
if (true) {
  let n = 10;
}
console.log(n); // 5
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;块级作用域和函数声明。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 允许在块级作用域内声明函数。
2. 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
3. 同时，函数声明还会提升到所在的块级作用域的头部。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h4 id=&quot;const&quot;&gt;const&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;声明一个只读的常量。一旦声明，常量的值就不能改变。&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; 只有声明没有赋值是会报错的。&lt;/li&gt;
  &lt;li&gt;
    &lt;pre&gt;&lt;code class=&quot;language-cosnt```的本质；&quot;&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
对于简单类型的数据(数值、字符串、布尔值)，值就保存在变量指向的那个内存地址，因此等同于常量。
对于复合类型的数据(主要是对象和数组),变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的。&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;例如：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;const foo = {};&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// 为 foo 添加一个属性，可以成功
foo.prop = 123;
console.log(foo.prop) // 123&lt;/p&gt;

&lt;p&gt;// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: “foo” is read-only&lt;/p&gt;

&lt;p&gt;// 如果需要冻结对象，不允许给对象添加属性
const foo = Object.freeze({});
// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ES6声明变量的6中方式：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var - function - let - const - import - class&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 顶层对象属性
顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。

为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1&lt;/p&gt;

&lt;p&gt;let b = 1;
window.b // undefined&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。

### 2. 变量的解构赋值
解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 1.数组的解构赋值
- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(```Destructuring```)

#### 2.对象的解构赋值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let {foo} = {bar: ‘baz’};
foo // undefined&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 3. 字符串的解构赋值
- 字符串被转换成了一个类似数组的对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const [a, b, c, d, e] = ‘hello’;
a // “h”
b // “e”
c // “l”
d // “l”
e // “o”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 4. 数值和布尔值的解构赋值
- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let {toString: s} = 123;
s === Number.prototype.toString // true&lt;/p&gt;

&lt;p&gt;let {toString: s} = true;
s === Boolean.prototype.toString // true&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 5.函数参数的解构赋值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function add([x, y]){
  return x + y;
}&lt;/p&gt;

&lt;p&gt;add([1, 2]); // 3&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;带有默认值的函数参数值的解构
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function move({x = 0, y = 0} = {}) {
  return [x, y];
}&lt;/p&gt;

&lt;p&gt;move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 6.用途
- 遍历map结构
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const map = new Map();
map.set(‘first’, ‘hello’);
map.set(‘second’, ‘world’);&lt;/p&gt;

&lt;p&gt;for (let [key, value] of map) {
  console.log(key + “ is “ + value);
}
// first is hello
// second is world&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 输入模块的指定方法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const { SourceMapConsumer, SourceNode } = require(“source-map”);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
### 3. 关于字符串
- ```codePointAt```,能够正确处理4个字节储存的字符，返回一个字符的码点。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let s = ‘𠮷a’;&lt;/p&gt;

&lt;p&gt;s.codePointAt(0) // 134071
s.codePointAt(1) // 57271&lt;/p&gt;

&lt;p&gt;s.codePointAt(2) // 97&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;js会将上面的字符串解析为3个字符，```codePointAt```在第一个字符上，识别出了```𠮷```,正确返回32位的UTF-16字符的码点。```codePointAt```方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function is32Bit(c) {
  return c.codePointAt(0) &amp;gt; 0xFFFF;
}&lt;/p&gt;

&lt;p&gt;is32Bit(“𠮷”) // true
is32Bit(“a”) // false&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ```String.fromCodePoint()```:ES6提供了String.fromCodePoint方法，可以识别大于```0xFFFF```的字符，弥补了```String.fromCharCode```方法的不足。在作用上，正好与```codePointAt```方法相反。在作用上，正好与codePointAt方法相反。

- ```at()```:可以识别 Unicode 编号大于```0xFFFF```的字符，返回正确的字符。
- ```normalize()```:ES6 提供字符串实例的```normalize()```方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。```normalize```方法可以接受一个参数来指定```normalize```的方式，参数的四个可选值如下。

&amp;gt; NFC, 默认参数，表示“标准等价合成”（Normalization Form Canonical Composition）返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。

&amp;gt; NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。

&amp;gt; NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）

&amp;gt; NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘\u004F\u030C’.normalize(‘NFC’).length // 1
‘\u004F\u030C’.normalize(‘NFD’).length // 2
// NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- 判断字符串包含另外字符串的方法

&amp;gt; indexOf(): 来自JavaScript。返回某个指定的字符串值在字符串中首次出现的位置。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘hemei’.indexOf(‘h’) // 0
‘hemei’.indexOf(‘i’) // 4&lt;/p&gt;

&lt;p&gt;const i = ‘hemei’.indexOf(‘i’) &amp;gt; -1
// i = true  表示能找到i&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;gt; includes()：返回布尔值，表示是否找到了参数字符串。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a = ‘hemei’.includes(‘i’)
// a = true&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;gt; startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘hemei’.startsWith(‘he’) // true
‘hemei’.startsWith(‘e’) //fales&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;gt; endsWith(): 返回Boolean，表示参数字符串是否在原字符串的尾部。

&amp;gt; includes, startsWith, endsWith 都支持第二个参数，表示开始搜索的位置。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let s = ‘Hello world!’;
s.startsWith(‘world’, 6) // true
s.endsWith(‘Hello’, 5) // true
s.includes(‘Hello’, 6) // false&lt;/p&gt;

&lt;p&gt;// 使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- repeat(): repeat方法返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整。参数是负数或者```Infinity```，会报错。参数```NaN```等同于0。参数是字符串，等同于0.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘x’.repeat(3) // “xxx”
‘hello’.repeat(2) // “hellohello”
‘hello’.repeat(2.1) // “hellohello”
‘hello’.repeat(2.9) // “hellohello”
‘na’.repeat(0) // “”
‘na’.repeat(NaN) // “”
‘na’.repeat(‘na’) // “”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- 字符串的自动补全。```padStart()，padEnd()``` ```padStart()```用于头部补全，```padEnd()```用于尾部补全。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘hemei’.padStart(10, ‘e’) // “eeeeehemei”
‘hemei’.padEnd(10, ‘e’) // “hemeieeeee”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意： 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。
如果省略第二个参数，默认使用空格补全长度。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 模板字符串
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;$(‘#result’).append(&lt;code class=&quot;highlighter-rouge&quot;&gt;
  There are &amp;lt;b&amp;gt;${basket.count}&amp;lt;/b&amp;gt; items
   in your basket, &amp;lt;em&amp;gt;${basket.onSale}&amp;lt;/em&amp;gt;
  are on sale!
&lt;/code&gt;);
// 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
### 数值
#### 1.扩展方法

- ```Number.isFinite()，Number.isNaN()```

```Number.isFinite()```用来检查一个数值是否为有限的```（finite）```。

```Number.isNaN()``` 用来检查一个值是否为空。

- ```Number.parseInt(), Number.parseFloat()```

ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;parseInt(12.1),  Number.parseInt(12.1) //12
parseFloat(‘123.45#’) , Number.parseFloat(‘123.45#’) // 123.45&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ```Number.isInteger()```

用来判断一个值是否为整数

#### 2.Math对象的扩展
- ```Math.trunc()```

    ```Math.trunc()```方法用于去除一个数的小数部分，返回整数部分。对于非数值，Math.trunc内部使用Number方法将其先转为数值。对于空值和无法截取整数的值，返回NaN。
- ```Math.sign() ```

    Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。
    ```
    +1 =&amp;gt; 参数为正数；
    -1 =&amp;gt; 参数为负数；
    0 =&amp;gt; 参数为0；
    -0 =&amp;gt; 参数为-0；
    NaN =&amp;gt; 其他值；

    ```

- ```Math.cbrt()```

该方法用于计算一个数的平方根

### 函数
#### 1.函数的 length 属性

将返回没有指定默认值的参数个数，functionName.length = 参数个数 - 指定了默认值的参数个数

#### 2. rest 参数
rest 参数（形式为```...变量名```），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

rest 参数只能是最后一个参数。

函数的length属性，不包括 rest 参数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function add(…values) {
  let sum = 0;&lt;/p&gt;

&lt;p&gt;for (var val of values) {
    sum += val;
  }&lt;/p&gt;

&lt;p&gt;return sum;
}&lt;/p&gt;

&lt;p&gt;add(2, 5, 3) // 10&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 3. 严格模式 'use strict';
es6规定，只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

#### 4. 箭头函数
注意：

- 函数体内的```this```对象，就是定义时所在的对象，而不是使用时所在的对象。
- 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
- 不可以使用```arguments```对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
- 不可以使用```yield```命令，因此箭头函数不能用作 ```Generator``` 函数。

#### 5. 双冒号运算符
函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。
用来取代```bind , call , apply```

### 数组
#### 扩展运算符
扩展运算符（spread）是三个点（```...```）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function f(z,x,c,v,b,n,m) {
    console.log(z,x,c,v,b,n,m)
}&lt;/p&gt;

&lt;p&gt;const arr = [2,33,44,66]&lt;/p&gt;

&lt;p&gt;f(1,…arr,2,4) // 1 2 33 44 66 2 4&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 扩展运算符的应用
- 复制数组。数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。所以使用扩展运算符```...```来进行数组的复制。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a1 = [1, 2];
const a2 = a1;&lt;/p&gt;

&lt;p&gt;a2[0] = 2;
a1 // [2, 2]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如下：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a1 = [2,3]
const a2 = […a1]
a2[0] = 4
a2 // [4,3]
a1 // [2,3]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 合并数组
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a1 = [2,3,4]
const a2 = [5,6,7]
const a3 = […a1, …a2]
a3 // [2, 3, 4, 5, 6, 7]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 与解构赋值结合
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const [a, …b] = [2,4,5,6,7,8]
a //2
b // [4,5,6,7,8]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意： 如果将扩展运算符用于数组赋值，只能放在参数的最后一位

- 字符串：扩展运算符可以将字符串转换为数组
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a = […‘hemei’]
a // [“h”, “e”, “m”, “e”, “i”]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 实现了 ```Iterator``` 接口的对象。```Iterator```接口对象，使用扩展运算符，将其转换为数组。
- Map 和 Set 结构，Generator 函数

#### ```Array.from()```
常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。

只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。

扩展运算符（```...```）也可以将某些数据结构转为数组。

扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。

任何有length属性的对象，都可以通过Array.from方法转为数组，此时的扩展运算符就无法转换。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Array.from([1, 2, 3], (x) =&amp;gt; x * x) // [1, 4, 9]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### ```Array.of```
```Array.of ```方法用于将一组值，转换为数组。

```Array.of```: 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。

#### 数组的 ```copyWithin```

将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。

它接受三个参数：

- target（必传）:从该位置开始替换数据。
- start（非必传）: 从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
- end（非必传）: 到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[‘hhhh’,’mmmm’,’eeeee’].copyWithin(0,2)//[“eeeee”, “mmmm”, “eeeee”]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### ```find()``` 和 ```findIndex()```
- ```find()```:找到第一个满足条件的数据并返回。
- ```findeIndex()```：找到满足条件的第一个元素，返回其下标，没有找到返回-1

#### ```fill()```
- fill(): 给定值，填充一个数组。可接受3个参数，第一个为填充的值，第二个是开始位置，第三个参数是结束位置.

#### ```entries()，keys() 和 values()```
- ```keys()```是对键名的遍历.
- ```values()```是对键值的遍历.
- ```entries()```是对键值对的遍历。

#### ```includes()```
跟```findIndex()```的区别:

indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[NaN].includes(NaN) //true
[NaN].indexOf(NaN) //-1&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意与has的区别：

Map 结构的has方法，是用来查找键名的

Set 结构的has方法，是用来查找值的

#### 数组的空位
数组的空位指，数组的某一个位置没有任何值

空位不是```undefined```，一个位置的值等于```undefined```，依然是有值的
ES6 是将空位转为```undefined```

### 对象的扩展

#### 对象的简洁表示法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let birth = ‘2000/01/01’;&lt;/p&gt;

&lt;p&gt;const Person = {&lt;/p&gt;

&lt;p&gt;name: ‘张三’,&lt;/p&gt;

&lt;p&gt;//等同于birth: birth
  birth,&lt;/p&gt;

&lt;p&gt;// 等同于hello: function ()…
  hello() { console.log(‘我的名字是’, this.name); }&lt;/p&gt;

&lt;p&gt;};&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果某个方法的值是一个 Generator 函数，前面需要加上星号。

#### ```Object.is() ```
    +0 === -0 //true
    NaN === NaN // false
    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true

#### ```Object.assign()```
```Object.assign```方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```Object.assign```方法的第一个参数是目标对象，后面的参数都是源对象.

注意：
如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

常见用途:
- 为对象添加属性.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 为对象添加方法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});
// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 克隆对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function clone(origin) {
  return Object.assign({}, origin);
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 合并多个对象: 将多个对象合并到某个对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const merge = (target, …sources) =&amp;gt; Object.assign(target, …sources);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 为属性指定默认值


#### 可枚举性 
- ```Object.getOwnPropertyDescriptor```方法可以获取该属性的描述对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意: 描述对象的 enumerable 属性，称为可枚举性。
当enumerable的值为false时，以下操作会被忽略：&lt;/p&gt;

&lt;p&gt;for…in循环：只遍历对象自身的和继承的可枚举的属性。
Object.keys()：返回对象自身的所有可枚举的属性的键名。
JSON.stringify()：只串行化对象自身的可枚举的属性。
Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。&lt;/p&gt;

&lt;p&gt;ES6 规定，所有 Class 的原型的方法都是不可枚举的。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 对象属性的遍历
- ```for...in```: 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。
- ```Object.keys(obj)```: 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
- ```Object.getOwnPropertyNames(obj)```: 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名.
- ```Object.getOwnPropertySymbols(obj)```: 返回一个数组，包含对象自身的所有 Symbol 属性的键名。
- ```Reflect.ownKeys(obj)```: 返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

#### ```Object.getOwnPropertyDescriptors```
返回指定对象所有自身属性（非继承属性）的描述对象。

#### ```Object.setPrototypeOf()```
用来设置一个对象的prototype对象，返回参数对象本身。
#### ```Object.getPrototypeOf() ```
用于读取一个对象的原型对象。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let obj1 = {}
let obj = {
    foo: 123,
    bar: function() {
        return ‘asdfggh’
    }
}
Object.setPrototypeOf(obj, obj1)
obj1.a = 22222
obj1.c = 33333&lt;/p&gt;

&lt;p&gt;obj //{foo: 123, bar: ƒ()}
Object.getPrototypeOf(obj)&lt;/p&gt;

&lt;p&gt;// {
//    a: 22222,
//    c: 33333
//}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### super 关键字 
指向当前对象的原型对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const proto = {
  foo: ‘hello’
};&lt;/p&gt;

&lt;p&gt;const obj = {
  find() {
    return super.foo;
  }
};&lt;/p&gt;

&lt;p&gt;Object.setPrototypeOf(obj, proto);
obj.find() // “hello”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意: super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。

#### ```Object.keys()，Object.values()，Object.entries()```

#### 对象的扩展运算符
- 解构赋值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let { x, y, …z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // {a: 3, b: 4}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;解构赋值必须是最后一个参数, 扩展运算符的解构赋值，不能复制继承自原型对象的属性。
- 扩展运算符：（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。

#### Null 传导运算符
?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。

### Symbol
为了保证每个属性的名字都是独一无二的，防止属性名的冲突。

Symbol 值作为对象属性名时，不能用点运算符

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let s = Symbol();&lt;/p&gt;

&lt;p&gt;typeof s&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
### Set &amp;amp; Map

#### Set 
Set 本身是一个构造函数，用来生成 Set 数据结构。Set 类似一个数组，成员的值都是唯一的

应用场景: 可以用来去除数组的重复值。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a = new Set();
[1,1,2,2,4,3,6,6,7,7].forEach(x =&amp;gt; a.add(x))
a // [1,2,4,3,6,7]
注意： Chrome 的console下，数组前面的代码一定要加上分号，否则会报错。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- Set 的遍历：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员&lt;/p&gt;

&lt;p&gt;注意: Set的遍历顺序就是插入顺序&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;和扩展运算符一起使用:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);&lt;/p&gt;

&lt;p&gt;// 并集
let union = new Set([…a, …b]);
// Set {1, 2, 3, 4}&lt;/p&gt;

&lt;p&gt;// 交集
let intersect = new Set([…a].filter(x =&amp;gt; b.has(x)));
// set {2, 3}&lt;/p&gt;

&lt;p&gt;// 差集
let difference = new Set([…a].filter(x =&amp;gt; !b.has(x)));
// Set {1}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### WeakSet
WeakSet 的成员只能是对象，而不能是其他类型的值。

WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

WeakSet 的原生方法:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#### Map
- size: 属性值，返回map结构的成员数
- set(key, value): 方法，设置map结构成员
- get(key): 方法, 读取key对应的键值，如果找不到key，返回undefined。
- has(key): 方法，返回Boolean值，表示某个键值是否在定义的map结构对象中
- delete(key): 方法，删除某个键值，返回Boolean值，表示是否删除成功
- clear(): 方法，清空当前map结构的成员。

##### 遍历
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。
注意: Map 的遍历顺序就是插入顺序。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const map = new Map();
map.set(‘foo’, true);
map.set(‘bar’, false);
map.set(‘hahaha’, ‘ddddd’);&lt;/p&gt;

&lt;p&gt;map.forEach(function(value, key, map) {
  console.log(“Key: %s, Value: %s”, key, value);
});
// Key: foo, Value: true
// Key: bar, Value: false
// Key: hahaha, Value: ddddd&lt;/p&gt;

&lt;p&gt;// forEach方法还可以接受第二个参数，用来绑定this。
const reporter = {
  report: function(key, value) {
    console.log(“Key: %s, Value: %s”, key, value);
  }
};&lt;/p&gt;

&lt;p&gt;map.forEach(function(value, key, map) {
  this.report(key, value);
}, reporter);&lt;/p&gt;

&lt;p&gt;// map转对象
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}
strMapToObj(map)&lt;/p&gt;

&lt;p&gt;// 对象转map&lt;/p&gt;

&lt;p&gt;function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}
objToStrMap(strMapToObj(map))&lt;/p&gt;

&lt;p&gt;// map 转JSON&lt;/p&gt;

&lt;p&gt;JSON.stringify(strMapToObj(map))
// “{“foo”:true,”bar”:false,”hahaha”:”ddddd”}”&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#### weakMap
weakMap 和Map 的区别：
- WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
- WeakMap的键名所指向的对象，不计入垃圾回收机制。

### Proxy
在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。```Proxy``` 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”.
```Proxy``` 支持的拦截:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;set(target, propKey, value, receiver):用于拦截对象属性的设置;
get(target, propKey, receiver): 拦截对象属性的读取;
has(target, propKey): 拦截propKey in proxy的操作，返回一个布尔值。
deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
ownKeys(target): 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
getOwnPropertyDescriptor(target, propKey): 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
defineProperty(target, propKey, propDesc): 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
preventExtensions(target): 拦截Object.preventExtensions(proxy)，返回一个布尔值。
getPrototypeOf(target):  拦截Object.getPrototypeOf(proxy)，返回一个对象。
isExtensible(target): 拦截Object.isExtensible(proxy)，返回一个布尔值。
setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
apply(target, object, args): 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。
construct(target, args): 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ```get(target, propKey, receiver)```:参数依次是 目标对象、属性名和 proxy 实例本身（即this关键字指向的那个对象），其中最后一个参数可选。
- ```set(target, propKey, value, receiver)```:可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。
- ```apply()```: 可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var target = function() {return “I’m the target”}
var handler = {
    apply:function() {
        return “I’m the proxy”
    }
}
var p = new Proxy(target, handler)
p()//I’m the proxy
```&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/11/20/index/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/20/index/</guid>
        
        
      </item>
    
      <item>
        <title>关于flex的几个属性。</title>
        <description>&lt;h3 id=&quot;盒子的6个属性&quot;&gt;盒子的6个属性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1.flex-direction: 主轴的方向。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {
  flex-direction: row | row-reverse | column | column-reverse;
}
row: 水平方向，起点在左端。默认
row-reverse: 水平方向，起点在右端。
column: 垂直方向，起点在顶部。
column-reverse: 垂直方向，起点在底部。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;2.flex-wrap: 换行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
nowrap: 不换行。默认
wrap: 换行，第一行在上面。
wrap-reverse: 换行，第一行在下面。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;flex-flow: 是1.2的简写。默认值：row nowrap&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {
  flex-flow: &amp;lt;flex-direction&amp;gt; || &amp;lt;flex-wrap&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;justify-content: 在主轴上的对齐方式。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
flex-start: 左对齐 默认
flex-end: 右对齐
center: 居中
space-between: 两端对齐，项目之间的间隔都相等。
space-around: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;align-item: 交叉轴上如何对齐。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {

  align-items: flex-start | flex-end | center | baseline | stretch;
}
flex-start: 交叉轴起点对齐。
flex-end: 交叉轴终点对齐。
center: 交叉轴中点对齐。
baseline: item的第一行文字基线对齐。
stretch: 如果项目未设置高度或设为auto，将占满整个容器的高度。默认
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;align-content: 多根轴线的对齐方式。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
flex-start：与交叉轴的起点对齐。
flex-end: 与交叉轴终点对齐。
center: 与交叉轴的中点对齐。
space-between: 与交叉轴两端对齐，项目之间的间隔都相等。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch：轴线占满整个交叉轴。默认
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;项目的6个属性&quot;&gt;项目的6个属性&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;order: 定义项目的排列顺序。数值越小，排列越靠前，默认为0。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;.item {
  order: &lt;integer&gt;;
}&lt;/integer&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;2.flex-grew: 定义项目的放大比例，默认为0。即如果存在剩余空间，也不放大。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
flex-grow: &amp;lt;number&amp;gt;; /* default 0 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;flex-shrink: 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
flex-shrink: &amp;lt;number&amp;gt;; /* default 1 */
}
 // 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间（main size）.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
flex-basis: &amp;lt;length&amp;gt; | auto; /* default auto */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;flex: 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
flex: none | [ &amp;lt;'flex-grow'&amp;gt; &amp;lt;'flex-shrink'&amp;gt;? || &amp;lt;'flex-basis'&amp;gt; ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;6.align-self: 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 11 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/11/index/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/11/index/</guid>
        
        
      </item>
    
      <item>
        <title>关于VUE</title>
        <description>&lt;p&gt;注：Vue不支持IE8及更低版本浏览器，因为Object.defindeProperty 仅支持ES5.
***&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;控制元素的可重用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-show&lt;/code&gt; 不支持&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-if&lt;/code&gt; 是真实的条件渲染，因为它会确保条件块在切换当中适当地小会和重建条件块内的事件监听和子组件。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-if&lt;/code&gt;也是惰性的,如果在初始渲染的条件为假，则什么也不做，在条件第一次变为真的时候才开始局部编译（编译会被缓存下来）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-show&lt;/code&gt;的元素一开始是被编译保留的。只是简单的css切换&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-for=&quot;(item, index) in items&quot;&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;表示当前(ˇˍˇ) 项的索引&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-for=&quot;(value, key, index) in object&quot;&lt;/code&gt;对象迭代，第二个参数为键名，第三个位索引&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; v-for=&quot;n in 10&quot;&lt;/code&gt; 整数迭代。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;理想值是每一项唯一的id，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;v-bind&lt;/code&gt;来绑定，建议尽可能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;v-for&lt;/code&gt;来提供&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;….&lt;/li&gt;
  &lt;li&gt;数组：&lt;code class=&quot;highlighter-rouge&quot;&gt;push(),pop(),shift(),unshift(),slice(),sort(),reverse()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vue&lt;/code&gt; 不能检测以下变动的数组:
    &lt;ul&gt;
      &lt;li&gt;利用索引直接设置一个项&lt;code class=&quot;highlighter-rouge&quot;&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; 
解决方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;Vue.set(example1.items, indexOfItem, newValue)&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;example1.items.splice(indexOfItem, 1, newValue)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;修改数组的长度&lt;code class=&quot;highlighter-rouge&quot;&gt;vm.items.length = newLength&lt;/code&gt;
解决方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;example1.items.splice(newLength)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;事件修饰符：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.stop&lt;/code&gt; :阻止事件冒泡，&lt;code class=&quot;highlighter-rouge&quot;&gt;v-on:click.stop=&quot;doThis&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.prevent&lt;/code&gt;：不重复提交，&lt;code class=&quot;highlighter-rouge&quot;&gt;submit.prevent=&quot;onSubmit&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.capture&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.self&lt;/code&gt;: 只当事件在该元素本身（而不是子元素）触发时触发回调&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.once&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;按键修饰符，使用按键别名，可以通过全局&lt;code class=&quot;highlighter-rouge&quot;&gt;config.keyCodes&lt;/code&gt;对象自定义按键修饰符别名，例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;Vue.config.keyCodes.f1 = 112 &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;新增按键修饰符:&lt;code class=&quot;highlighter-rouge&quot;&gt;.ctrl&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.alt&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.shift&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.meta&lt;/code&gt;,在按键按下时发生响应！&lt;/li&gt;
  &lt;li&gt;表单控件绑定：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.lazy&lt;/code&gt; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;change&lt;/code&gt;事件中同步： &lt;code class=&quot;highlighter-rouge&quot;&gt;v-model.lazy=&quot;message&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.number&lt;/code&gt; 将用户输入值转为number类型: &lt;code class=&quot;highlighter-rouge&quot;&gt;v-model.number=&quot;age&quot;&lt;/code&gt;,即使在&lt;code class=&quot;highlighter-rouge&quot;&gt;type=&quot;number&quot;&lt;/code&gt;时，html输入的值也是字符串类型&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.trim&lt;/code&gt; 自动过滤掉用户输入的首尾空格&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;组件：&lt;code class=&quot;highlighter-rouge&quot;&gt; Vue.component(tagName,options)&lt;/code&gt;,建议命名&lt;code class=&quot;highlighter-rouge&quot;&gt;小写，并且包含一个短杠&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;DOM 模板解析说明，固定子节点的DOM(如 ul 里面的li，table 的 tr…)的组件会被认为是无效内容，这时需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;is&lt;/code&gt;属性：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;table&amp;gt;
    &amp;lt;tr is=&quot;my-row&quot;&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果使用来自以下来源的字符串模板，就不受到以上限制：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. `&amp;lt;script type=&quot;text/x-template&quot;&amp;gt;` 
2. javascript 内联模板字符串
3. `.vue`组件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 必须是函数&lt;/li&gt;
  &lt;li&gt;组件构成，子父组件的关系：&lt;code class=&quot;highlighter-rouge&quot;&gt;props down&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;events up&lt;/code&gt;,父组件通过props向下传递数据给子组件，子组件通过events给父组件发送消息。&lt;/li&gt;
  &lt;li&gt;动态Prop 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;v-bind&lt;/code&gt;动态绑定&lt;code class=&quot;highlighter-rouge&quot;&gt;props&lt;/code&gt;的值到父组件的数据中，父组件值发生变化时，该变化也会传导给子组件。&lt;/li&gt;
  &lt;li&gt;单向数据流！&lt;code class=&quot;highlighter-rouge&quot;&gt;注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;自定义事件：&lt;code class=&quot;highlighter-rouge&quot;&gt;$on(eventName)&lt;/code&gt;监听事件，&lt;code class=&quot;highlighter-rouge&quot;&gt;$emit(eventName)&lt;/code&gt;触发事件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;slot&lt;/code&gt; 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;属性来分发内容。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;keep-aoive&lt;/code&gt;,把切换出去的组件保留在内存中，保留它的状态或避免重新渲染。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vue.component('async-example', function (resolve, reject) {
setTimeout(function () {
  // Pass the component definition to the resolve callback
  resolve({
    template: '&amp;lt;div&amp;gt;I am async!&amp;lt;/div&amp;gt;'
  })
}, 1000)
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;resolve 是回调,&lt;code class=&quot;highlighter-rouge&quot;&gt;reject(reason)&lt;/code&gt;只是加载失败。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;递归调用组件。只有当它有name选项的时候才能自己调用自己。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;v-once&lt;/code&gt; ，将渲染的静态组件缓存起来。&lt;/li&gt;
  &lt;li&gt;声明响应式，由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vue&lt;/code&gt; 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值，也就是在data中声明。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 13 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/13/index/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/13/index/</guid>
        
        
      </item>
    
  </channel>
</rss>
