<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AntoniaHE Blog</title>
    <description>Every failure is leading towards success.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 21 May 2018 23:36:09 +0800</pubDate>
    <lastBuildDate>Mon, 21 May 2018 23:36:09 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>关于ES6</title>
        <description>&lt;h3 id=&quot;1-let-和-const-命令&quot;&gt;1. let 和 const 命令&lt;/h3&gt;
&lt;p&gt;ES6 新增了&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;命令，用来声明变量。只在&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;所在的区块内有效。&lt;/p&gt;
&lt;h4 id=&quot;let&quot;&gt;let&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;不存在变量提升。&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;会有变量提升的情况，也就是可以在声明之前使用，其值为&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;定义的变量，只能在声明后使用，否则报错&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;暂时性死区。在代码块内，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（&lt;code class=&quot;highlighter-rouge&quot;&gt;temporal dead zone&lt;/code&gt;，简称 &lt;code class=&quot;highlighter-rouge&quot;&gt;TDZ&lt;/code&gt;）。&lt;/li&gt;
  &lt;li&gt;不允许重复声明。&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;不允许在相同作用域内，重复声明同一个变量。&lt;/li&gt;
  &lt;li&gt;块级作用域。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;为什么需要块级作用域?
第一种场景，如果使用var内层变量可能会覆盖外层变量。
第二种场景，用来计数的循环变量泄露为全局变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;ES6的块级作用域：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function f1() {
let n = 5;
if (true) {
  let n = 10;
}
console.log(n); // 5
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;块级作用域和函数声明。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 允许在块级作用域内声明函数。
2. 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
3. 同时，函数声明还会提升到所在的块级作用域的头部。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h4 id=&quot;const&quot;&gt;const&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;声明一个只读的常量。一旦声明，常量的值就不能改变。&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; 只有声明没有赋值是会报错的。&lt;/li&gt;
  &lt;li&gt;
    &lt;pre&gt;&lt;code class=&quot;language-cosnt```的本质；&quot;&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
对于简单类型的数据(数值、字符串、布尔值)，值就保存在变量指向的那个内存地址，因此等同于常量。
对于复合类型的数据(主要是对象和数组),变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的。&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;例如：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;const foo = {};&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// 为 foo 添加一个属性，可以成功
foo.prop = 123;
console.log(foo.prop) // 123&lt;/p&gt;

&lt;p&gt;// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: “foo” is read-only&lt;/p&gt;

&lt;p&gt;// 如果需要冻结对象，不允许给对象添加属性
const foo = Object.freeze({});
// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ES6声明变量的6中方式：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var - function - let - const - import - class&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 顶层对象属性
顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。

为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1&lt;/p&gt;

&lt;p&gt;let b = 1;
window.b // undefined&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。

### 2. 变量的解构赋值
解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 1.数组的解构赋值
- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(```Destructuring```)

#### 2.对象的解构赋值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let {foo} = {bar: ‘baz’};
foo // undefined&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 3. 字符串的解构赋值
- 字符串被转换成了一个类似数组的对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const [a, b, c, d, e] = ‘hello’;
a // “h”
b // “e”
c // “l”
d // “l”
e // “o”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 4. 数值和布尔值的解构赋值
- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let {toString: s} = 123;
s === Number.prototype.toString // true&lt;/p&gt;

&lt;p&gt;let {toString: s} = true;
s === Boolean.prototype.toString // true&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 5.函数参数的解构赋值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function add([x, y]){
  return x + y;
}&lt;/p&gt;

&lt;p&gt;add([1, 2]); // 3&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;带有默认值的函数参数值的解构
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function move({x = 0, y = 0} = {}) {
  return [x, y];
}&lt;/p&gt;

&lt;p&gt;move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 6.用途
- 遍历map结构
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const map = new Map();
map.set(‘first’, ‘hello’);
map.set(‘second’, ‘world’);&lt;/p&gt;

&lt;p&gt;for (let [key, value] of map) {
  console.log(key + “ is “ + value);
}
// first is hello
// second is world&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 输入模块的指定方法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const { SourceMapConsumer, SourceNode } = require(“source-map”);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
### 3. 关于字符串
- ```codePointAt```,能够正确处理4个字节储存的字符，返回一个字符的码点。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let s = ‘𠮷a’;&lt;/p&gt;

&lt;p&gt;s.codePointAt(0) // 134071
s.codePointAt(1) // 57271&lt;/p&gt;

&lt;p&gt;s.codePointAt(2) // 97&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;js会将上面的字符串解析为3个字符，```codePointAt```在第一个字符上，识别出了```𠮷```,正确返回32位的UTF-16字符的码点。```codePointAt```方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function is32Bit(c) {
  return c.codePointAt(0) &amp;gt; 0xFFFF;
}&lt;/p&gt;

&lt;p&gt;is32Bit(“𠮷”) // true
is32Bit(“a”) // false&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ```String.fromCodePoint()```:ES6提供了String.fromCodePoint方法，可以识别大于```0xFFFF```的字符，弥补了```String.fromCharCode```方法的不足。在作用上，正好与```codePointAt```方法相反。在作用上，正好与codePointAt方法相反。

- ```at()```:可以识别 Unicode 编号大于```0xFFFF```的字符，返回正确的字符。
- ```normalize()```:ES6 提供字符串实例的```normalize()```方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。```normalize```方法可以接受一个参数来指定```normalize```的方式，参数的四个可选值如下。

&amp;gt; NFC, 默认参数，表示“标准等价合成”（Normalization Form Canonical Composition）返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。

&amp;gt; NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。

&amp;gt; NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）

&amp;gt; NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘\u004F\u030C’.normalize(‘NFC’).length // 1
‘\u004F\u030C’.normalize(‘NFD’).length // 2
// NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- 判断字符串包含另外字符串的方法

&amp;gt; indexOf(): 来自JavaScript。返回某个指定的字符串值在字符串中首次出现的位置。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘hemei’.indexOf(‘h’) // 0
‘hemei’.indexOf(‘i’) // 4&lt;/p&gt;

&lt;p&gt;const i = ‘hemei’.indexOf(‘i’) &amp;gt; -1
// i = true  表示能找到i&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;gt; includes()：返回布尔值，表示是否找到了参数字符串。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a = ‘hemei’.includes(‘i’)
// a = true&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;gt; startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘hemei’.startsWith(‘he’) // true
‘hemei’.startsWith(‘e’) //fales&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;gt; endsWith(): 返回Boolean，表示参数字符串是否在原字符串的尾部。

&amp;gt; includes, startsWith, endsWith 都支持第二个参数，表示开始搜索的位置。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let s = ‘Hello world!’;
s.startsWith(‘world’, 6) // true
s.endsWith(‘Hello’, 5) // true
s.includes(‘Hello’, 6) // false&lt;/p&gt;

&lt;p&gt;// 使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- repeat(): repeat方法返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整。参数是负数或者```Infinity```，会报错。参数```NaN```等同于0。参数是字符串，等同于0.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘x’.repeat(3) // “xxx”
‘hello’.repeat(2) // “hellohello”
‘hello’.repeat(2.1) // “hellohello”
‘hello’.repeat(2.9) // “hellohello”
‘na’.repeat(0) // “”
‘na’.repeat(NaN) // “”
‘na’.repeat(‘na’) // “”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- 字符串的自动补全。```padStart()，padEnd()``` ```padStart()```用于头部补全，```padEnd()```用于尾部补全。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;‘hemei’.padStart(10, ‘e’) // “eeeeehemei”
‘hemei’.padEnd(10, ‘e’) // “hemeieeeee”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意： 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。
如果省略第二个参数，默认使用空格补全长度。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 模板字符串
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;$(‘#result’).append(&lt;code class=&quot;highlighter-rouge&quot;&gt;
  There are &amp;lt;b&amp;gt;${basket.count}&amp;lt;/b&amp;gt; items
   in your basket, &amp;lt;em&amp;gt;${basket.onSale}&amp;lt;/em&amp;gt;
  are on sale!
&lt;/code&gt;);
// 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
### 数值
#### 1.扩展方法

- ```Number.isFinite()，Number.isNaN()```

```Number.isFinite()```用来检查一个数值是否为有限的```（finite）```。

```Number.isNaN()``` 用来检查一个值是否为空。

- ```Number.parseInt(), Number.parseFloat()```

ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;parseInt(12.1),  Number.parseInt(12.1) //12
parseFloat(‘123.45#’) , Number.parseFloat(‘123.45#’) // 123.45&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ```Number.isInteger()```

用来判断一个值是否为整数

#### 2.Math对象的扩展
- ```Math.trunc()```

    ```Math.trunc()```方法用于去除一个数的小数部分，返回整数部分。对于非数值，Math.trunc内部使用Number方法将其先转为数值。对于空值和无法截取整数的值，返回NaN。
- ```Math.sign() ```

    Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。
    ```
    +1 =&amp;gt; 参数为正数；
    -1 =&amp;gt; 参数为负数；
    0 =&amp;gt; 参数为0；
    -0 =&amp;gt; 参数为-0；
    NaN =&amp;gt; 其他值；

    ```

- ```Math.cbrt()```

该方法用于计算一个数的平方根

### 函数
#### 1.函数的 length 属性

将返回没有指定默认值的参数个数，functionName.length = 参数个数 - 指定了默认值的参数个数

#### 2. rest 参数
rest 参数（形式为```...变量名```），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

rest 参数只能是最后一个参数。

函数的length属性，不包括 rest 参数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function add(…values) {
  let sum = 0;&lt;/p&gt;

&lt;p&gt;for (var val of values) {
    sum += val;
  }&lt;/p&gt;

&lt;p&gt;return sum;
}&lt;/p&gt;

&lt;p&gt;add(2, 5, 3) // 10&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 3. 严格模式 'use strict';
es6规定，只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

#### 4. 箭头函数
注意：

- 函数体内的```this```对象，就是定义时所在的对象，而不是使用时所在的对象。
- 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
- 不可以使用```arguments```对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
- 不可以使用```yield```命令，因此箭头函数不能用作 ```Generator``` 函数。

#### 5. 双冒号运算符
函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。
用来取代```bind , call , apply```

### 数组
#### 扩展运算符
扩展运算符（spread）是三个点（```...```）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function f(z,x,c,v,b,n,m) {
    console.log(z,x,c,v,b,n,m)
}&lt;/p&gt;

&lt;p&gt;const arr = [2,33,44,66]&lt;/p&gt;

&lt;p&gt;f(1,…arr,2,4) // 1 2 33 44 66 2 4&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 扩展运算符的应用
- 复制数组。数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。所以使用扩展运算符```...```来进行数组的复制。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a1 = [1, 2];
const a2 = a1;&lt;/p&gt;

&lt;p&gt;a2[0] = 2;
a1 // [2, 2]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如下：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a1 = [2,3]
const a2 = […a1]
a2[0] = 4
a2 // [4,3]
a1 // [2,3]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 合并数组
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a1 = [2,3,4]
const a2 = [5,6,7]
const a3 = […a1, …a2]
a3 // [2, 3, 4, 5, 6, 7]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 与解构赋值结合
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const [a, …b] = [2,4,5,6,7,8]
a //2
b // [4,5,6,7,8]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意： 如果将扩展运算符用于数组赋值，只能放在参数的最后一位

- 字符串：扩展运算符可以将字符串转换为数组
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a = […‘hemei’]
a // [“h”, “e”, “m”, “e”, “i”]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 实现了 ```Iterator``` 接口的对象。```Iterator```接口对象，使用扩展运算符，将其转换为数组。
- Map 和 Set 结构，Generator 函数

#### ```Array.from()```
常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。

只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。

扩展运算符（```...```）也可以将某些数据结构转为数组。

扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。

任何有length属性的对象，都可以通过Array.from方法转为数组，此时的扩展运算符就无法转换。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Array.from([1, 2, 3], (x) =&amp;gt; x * x) // [1, 4, 9]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### ```Array.of```
```Array.of ```方法用于将一组值，转换为数组。

```Array.of```: 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。

#### 数组的 ```copyWithin```

将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。

它接受三个参数：

- target（必传）:从该位置开始替换数据。
- start（非必传）: 从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
- end（非必传）: 到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[‘hhhh’,’mmmm’,’eeeee’].copyWithin(0,2)//[“eeeee”, “mmmm”, “eeeee”]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### ```find()``` 和 ```findIndex()```
- ```find()```:找到第一个满足条件的数据并返回。
- ```findeIndex()```：找到满足条件的第一个元素，返回其下标，没有找到返回-1

#### ```fill()```
- fill(): 给定值，填充一个数组。可接受3个参数，第一个为填充的值，第二个是开始位置，第三个参数是结束位置.

#### ```entries()，keys() 和 values()```
- ```keys()```是对键名的遍历.
- ```values()```是对键值的遍历.
- ```entries()```是对键值对的遍历。

#### ```includes()```
跟```findIndex()```的区别:

indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[NaN].includes(NaN) //true
[NaN].indexOf(NaN) //-1&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意与has的区别：

Map 结构的has方法，是用来查找键名的

Set 结构的has方法，是用来查找值的

#### 数组的空位
数组的空位指，数组的某一个位置没有任何值

空位不是```undefined```，一个位置的值等于```undefined```，依然是有值的
ES6 是将空位转为```undefined```

### 对象的扩展

#### 对象的简洁表示法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let birth = ‘2000/01/01’;&lt;/p&gt;

&lt;p&gt;const Person = {&lt;/p&gt;

&lt;p&gt;name: ‘张三’,&lt;/p&gt;

&lt;p&gt;//等同于birth: birth
  birth,&lt;/p&gt;

&lt;p&gt;// 等同于hello: function ()…
  hello() { console.log(‘我的名字是’, this.name); }&lt;/p&gt;

&lt;p&gt;};&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果某个方法的值是一个 Generator 函数，前面需要加上星号。

#### ```Object.is() ```
    +0 === -0 //true
    NaN === NaN // false
    Object.is(+0, -0) // false
    Object.is(NaN, NaN) // true

#### ```Object.assign()```
```Object.assign```方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```Object.assign```方法的第一个参数是目标对象，后面的参数都是源对象.

注意：
如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

常见用途:
- 为对象添加属性.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 为对象添加方法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});
// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 克隆对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;function clone(origin) {
  return Object.assign({}, origin);
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 合并多个对象: 将多个对象合并到某个对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const merge = (target, …sources) =&amp;gt; Object.assign(target, …sources);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 为属性指定默认值


#### 可枚举性 
- ```Object.getOwnPropertyDescriptor```方法可以获取该属性的描述对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意: 描述对象的 enumerable 属性，称为可枚举性。
当enumerable的值为false时，以下操作会被忽略：&lt;/p&gt;

&lt;p&gt;for…in循环：只遍历对象自身的和继承的可枚举的属性。
Object.keys()：返回对象自身的所有可枚举的属性的键名。
JSON.stringify()：只串行化对象自身的可枚举的属性。
Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。&lt;/p&gt;

&lt;p&gt;ES6 规定，所有 Class 的原型的方法都是不可枚举的。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### 对象属性的遍历
- ```for...in```: 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。
- ```Object.keys(obj)```: 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
- ```Object.getOwnPropertyNames(obj)```: 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名.
- ```Object.getOwnPropertySymbols(obj)```: 返回一个数组，包含对象自身的所有 Symbol 属性的键名。
- ```Reflect.ownKeys(obj)```: 返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

#### ```Object.getOwnPropertyDescriptors```
返回指定对象所有自身属性（非继承属性）的描述对象。

#### ```Object.setPrototypeOf()```
用来设置一个对象的prototype对象，返回参数对象本身。
#### ```Object.getPrototypeOf() ```
用于读取一个对象的原型对象。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let obj1 = {}
let obj = {
    foo: 123,
    bar: function() {
        return ‘asdfggh’
    }
}
Object.setPrototypeOf(obj, obj1)
obj1.a = 22222
obj1.c = 33333&lt;/p&gt;

&lt;p&gt;obj //{foo: 123, bar: ƒ()}
Object.getPrototypeOf(obj)&lt;/p&gt;

&lt;p&gt;// {
//    a: 22222,
//    c: 33333
//}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### super 关键字 
指向当前对象的原型对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const proto = {
  foo: ‘hello’
};&lt;/p&gt;

&lt;p&gt;const obj = {
  find() {
    return super.foo;
  }
};&lt;/p&gt;

&lt;p&gt;Object.setPrototypeOf(obj, proto);
obj.find() // “hello”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;注意: super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。

#### ```Object.keys()，Object.values()，Object.entries()```

#### 对象的扩展运算符
- 解构赋值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let { x, y, …z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // {a: 3, b: 4}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;解构赋值必须是最后一个参数, 扩展运算符的解构赋值，不能复制继承自原型对象的属性。
- 扩展运算符：（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。

#### Null 传导运算符
?.运算符，只要其中一个返回null或undefined，就不再往下运算，而是返回undefined。

### Symbol
为了保证每个属性的名字都是独一无二的，防止属性名的冲突。

Symbol 值作为对象属性名时，不能用点运算符

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let s = Symbol();&lt;/p&gt;

&lt;p&gt;typeof s&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
### Set &amp;amp; Map

#### Set 
Set 本身是一个构造函数，用来生成 Set 数据结构。Set 类似一个数组，成员的值都是唯一的

应用场景: 可以用来去除数组的重复值。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const a = new Set();
[1,1,2,2,4,3,6,6,7,7].forEach(x =&amp;gt; a.add(x))
a // [1,2,4,3,6,7]
注意： Chrome 的console下，数组前面的代码一定要加上分号，否则会报错。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- Set 的遍历：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员&lt;/p&gt;

&lt;p&gt;注意: Set的遍历顺序就是插入顺序&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;和扩展运算符一起使用:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);&lt;/p&gt;

&lt;p&gt;// 并集
let union = new Set([…a, …b]);
// Set {1, 2, 3, 4}&lt;/p&gt;

&lt;p&gt;// 交集
let intersect = new Set([…a].filter(x =&amp;gt; b.has(x)));
// set {2, 3}&lt;/p&gt;

&lt;p&gt;// 差集
let difference = new Set([…a].filter(x =&amp;gt; !b.has(x)));
// Set {1}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#### WeakSet
WeakSet 的成员只能是对象，而不能是其他类型的值。

WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

WeakSet 的原生方法:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#### Map
- size: 属性值，返回map结构的成员数
- set(key, value): 方法，设置map结构成员
- get(key): 方法, 读取key对应的键值，如果找不到key，返回undefined。
- has(key): 方法，返回Boolean值，表示某个键值是否在定义的map结构对象中
- delete(key): 方法，删除某个键值，返回Boolean值，表示是否删除成功
- clear(): 方法，清空当前map结构的成员。

##### 遍历
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。
注意: Map 的遍历顺序就是插入顺序。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;const map = new Map();
map.set(‘foo’, true);
map.set(‘bar’, false);
map.set(‘hahaha’, ‘ddddd’);&lt;/p&gt;

&lt;p&gt;map.forEach(function(value, key, map) {
  console.log(“Key: %s, Value: %s”, key, value);
});
// Key: foo, Value: true
// Key: bar, Value: false
// Key: hahaha, Value: ddddd&lt;/p&gt;

&lt;p&gt;// forEach方法还可以接受第二个参数，用来绑定this。
const reporter = {
  report: function(key, value) {
    console.log(“Key: %s, Value: %s”, key, value);
  }
};&lt;/p&gt;

&lt;p&gt;map.forEach(function(value, key, map) {
  this.report(key, value);
}, reporter);&lt;/p&gt;

&lt;p&gt;// map转对象
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}
strMapToObj(map)&lt;/p&gt;

&lt;p&gt;// 对象转map&lt;/p&gt;

&lt;p&gt;function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}
objToStrMap(strMapToObj(map))&lt;/p&gt;

&lt;p&gt;// map 转JSON&lt;/p&gt;

&lt;p&gt;JSON.stringify(strMapToObj(map))
// “{“foo”:true,”bar”:false,”hahaha”:”ddddd”}”&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
#### weakMap
weakMap 和Map 的区别：
- WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
- WeakMap的键名所指向的对象，不计入垃圾回收机制。

### Proxy
在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。```Proxy``` 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”.
```Proxy``` 支持的拦截:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;set(target, propKey, value, receiver):用于拦截对象属性的设置;
get(target, propKey, receiver): 拦截对象属性的读取;
has(target, propKey): 拦截propKey in proxy的操作，返回一个布尔值。
deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
ownKeys(target): 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
getOwnPropertyDescriptor(target, propKey): 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
defineProperty(target, propKey, propDesc): 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
preventExtensions(target): 拦截Object.preventExtensions(proxy)，返回一个布尔值。
getPrototypeOf(target):  拦截Object.getPrototypeOf(proxy)，返回一个对象。
isExtensible(target): 拦截Object.isExtensible(proxy)，返回一个布尔值。
setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
apply(target, object, args): 拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。
construct(target, args): 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- ```get(target, propKey, receiver)```:参数依次是 目标对象、属性名和 proxy 实例本身（即this关键字指向的那个对象），其中最后一个参数可选。
- ```set(target, propKey, value, receiver)```:可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。
- ```apply()```: 可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;var target = function() {return “I’m the target”}
var handler = {
    apply:function() {
        return “I’m the proxy”
    }
}
var p = new Proxy(target, handler)
p()//I’m the proxy
```&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/11/20/index/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/11/20/index/</guid>
        
        
      </item>
    
      <item>
        <title>关于flex的几个属性。</title>
        <description>&lt;h3 id=&quot;盒子的6个属性&quot;&gt;盒子的6个属性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1.flex-direction: 主轴的方向。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {
  flex-direction: row | row-reverse | column | column-reverse;
}
row: 水平方向，起点在左端。默认
row-reverse: 水平方向，起点在右端。
column: 垂直方向，起点在顶部。
column-reverse: 垂直方向，起点在底部。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;2.flex-wrap: 换行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
nowrap: 不换行。默认
wrap: 换行，第一行在上面。
wrap-reverse: 换行，第一行在下面。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;flex-flow: 是1.2的简写。默认值：row nowrap&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {
  flex-flow: &amp;lt;flex-direction&amp;gt; || &amp;lt;flex-wrap&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;justify-content: 在主轴上的对齐方式。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
flex-start: 左对齐 默认
flex-end: 右对齐
center: 居中
space-between: 两端对齐，项目之间的间隔都相等。
space-around: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;align-item: 交叉轴上如何对齐。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {

  align-items: flex-start | flex-end | center | baseline | stretch;
}
flex-start: 交叉轴起点对齐。
flex-end: 交叉轴终点对齐。
center: 交叉轴中点对齐。
baseline: item的第一行文字基线对齐。
stretch: 如果项目未设置高度或设为auto，将占满整个容器的高度。默认
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;align-content: 多根轴线的对齐方式。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box {
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
flex-start：与交叉轴的起点对齐。
flex-end: 与交叉轴终点对齐。
center: 与交叉轴的中点对齐。
space-between: 与交叉轴两端对齐，项目之间的间隔都相等。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch：轴线占满整个交叉轴。默认
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;项目的6个属性&quot;&gt;项目的6个属性&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;order: 定义项目的排列顺序。数值越小，排列越靠前，默认为0。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;.item {
  order: &lt;integer&gt;;
}&lt;/integer&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;2.flex-grew: 定义项目的放大比例，默认为0。即如果存在剩余空间，也不放大。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
flex-grow: &amp;lt;number&amp;gt;; /* default 0 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;flex-shrink: 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
flex-shrink: &amp;lt;number&amp;gt;; /* default 1 */
}
 // 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间（main size）.
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
flex-basis: &amp;lt;length&amp;gt; | auto; /* default auto */
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;flex: 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
flex: none | [ &amp;lt;'flex-grow'&amp;gt; &amp;lt;'flex-shrink'&amp;gt;? || &amp;lt;'flex-basis'&amp;gt; ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;6.align-self: 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 11 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/04/11/index/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/11/index/</guid>
        
        
      </item>
    
      <item>
        <title>关于VUE</title>
        <description>&lt;p&gt;注：Vue不支持IE8及更低版本浏览器，因为Object.defindeProperty 仅支持ES5.
***&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;控制元素的可重用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-show&lt;/code&gt; 不支持&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-if&lt;/code&gt; 是真实的条件渲染，因为它会确保条件块在切换当中适当地小会和重建条件块内的事件监听和子组件。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-if&lt;/code&gt;也是惰性的,如果在初始渲染的条件为假，则什么也不做，在条件第一次变为真的时候才开始局部编译（编译会被缓存下来）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-show&lt;/code&gt;的元素一开始是被编译保留的。只是简单的css切换&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-for=&quot;(item, index) in items&quot;&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;表示当前(ˇˍˇ) 项的索引&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;v-for=&quot;(value, key, index) in object&quot;&lt;/code&gt;对象迭代，第二个参数为键名，第三个位索引&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt; v-for=&quot;n in 10&quot;&lt;/code&gt; 整数迭代。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;理想值是每一项唯一的id，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;v-bind&lt;/code&gt;来绑定，建议尽可能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;v-for&lt;/code&gt;来提供&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;….&lt;/li&gt;
  &lt;li&gt;数组：&lt;code class=&quot;highlighter-rouge&quot;&gt;push(),pop(),shift(),unshift(),slice(),sort(),reverse()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vue&lt;/code&gt; 不能检测以下变动的数组:
    &lt;ul&gt;
      &lt;li&gt;利用索引直接设置一个项&lt;code class=&quot;highlighter-rouge&quot;&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; 
解决方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;Vue.set(example1.items, indexOfItem, newValue)&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;example1.items.splice(indexOfItem, 1, newValue)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;修改数组的长度&lt;code class=&quot;highlighter-rouge&quot;&gt;vm.items.length = newLength&lt;/code&gt;
解决方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;example1.items.splice(newLength)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;事件修饰符：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.stop&lt;/code&gt; :阻止事件冒泡，&lt;code class=&quot;highlighter-rouge&quot;&gt;v-on:click.stop=&quot;doThis&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.prevent&lt;/code&gt;：不重复提交，&lt;code class=&quot;highlighter-rouge&quot;&gt;submit.prevent=&quot;onSubmit&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.capture&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.self&lt;/code&gt;: 只当事件在该元素本身（而不是子元素）触发时触发回调&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.once&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;按键修饰符，使用按键别名，可以通过全局&lt;code class=&quot;highlighter-rouge&quot;&gt;config.keyCodes&lt;/code&gt;对象自定义按键修饰符别名，例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;Vue.config.keyCodes.f1 = 112 &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;新增按键修饰符:&lt;code class=&quot;highlighter-rouge&quot;&gt;.ctrl&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.alt&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.shift&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.meta&lt;/code&gt;,在按键按下时发生响应！&lt;/li&gt;
  &lt;li&gt;表单控件绑定：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.lazy&lt;/code&gt; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;change&lt;/code&gt;事件中同步： &lt;code class=&quot;highlighter-rouge&quot;&gt;v-model.lazy=&quot;message&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.number&lt;/code&gt; 将用户输入值转为number类型: &lt;code class=&quot;highlighter-rouge&quot;&gt;v-model.number=&quot;age&quot;&lt;/code&gt;,即使在&lt;code class=&quot;highlighter-rouge&quot;&gt;type=&quot;number&quot;&lt;/code&gt;时，html输入的值也是字符串类型&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.trim&lt;/code&gt; 自动过滤掉用户输入的首尾空格&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;组件：&lt;code class=&quot;highlighter-rouge&quot;&gt; Vue.component(tagName,options)&lt;/code&gt;,建议命名&lt;code class=&quot;highlighter-rouge&quot;&gt;小写，并且包含一个短杠&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;DOM 模板解析说明，固定子节点的DOM(如 ul 里面的li，table 的 tr…)的组件会被认为是无效内容，这时需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;is&lt;/code&gt;属性：&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;table&amp;gt;
    &amp;lt;tr is=&quot;my-row&quot;&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果使用来自以下来源的字符串模板，就不受到以上限制：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. `&amp;lt;script type=&quot;text/x-template&quot;&amp;gt;` 
2. javascript 内联模板字符串
3. `.vue`组件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 必须是函数&lt;/li&gt;
  &lt;li&gt;组件构成，子父组件的关系：&lt;code class=&quot;highlighter-rouge&quot;&gt;props down&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;events up&lt;/code&gt;,父组件通过props向下传递数据给子组件，子组件通过events给父组件发送消息。&lt;/li&gt;
  &lt;li&gt;动态Prop 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;v-bind&lt;/code&gt;动态绑定&lt;code class=&quot;highlighter-rouge&quot;&gt;props&lt;/code&gt;的值到父组件的数据中，父组件值发生变化时，该变化也会传导给子组件。&lt;/li&gt;
  &lt;li&gt;单向数据流！&lt;code class=&quot;highlighter-rouge&quot;&gt;注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;自定义事件：&lt;code class=&quot;highlighter-rouge&quot;&gt;$on(eventName)&lt;/code&gt;监听事件，&lt;code class=&quot;highlighter-rouge&quot;&gt;$emit(eventName)&lt;/code&gt;触发事件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;slot&lt;/code&gt; 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;属性来分发内容。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;keep-aoive&lt;/code&gt;,把切换出去的组件保留在内存中，保留它的状态或避免重新渲染。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vue.component('async-example', function (resolve, reject) {
setTimeout(function () {
  // Pass the component definition to the resolve callback
  resolve({
    template: '&amp;lt;div&amp;gt;I am async!&amp;lt;/div&amp;gt;'
  })
}, 1000)
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;resolve 是回调,&lt;code class=&quot;highlighter-rouge&quot;&gt;reject(reason)&lt;/code&gt;只是加载失败。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;递归调用组件。只有当它有name选项的时候才能自己调用自己。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;v-once&lt;/code&gt; ，将渲染的静态组件缓存起来。&lt;/li&gt;
  &lt;li&gt;声明响应式，由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vue&lt;/code&gt; 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值，也就是在data中声明。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 13 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/13/index/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/13/index/</guid>
        
        
      </item>
    
  </channel>
</rss>
